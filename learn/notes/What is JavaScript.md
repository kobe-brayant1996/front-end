## What is JavaScript ?

+ ### `ECMAScript` 

  + ECMA-262 定义的语言
  + 没有输入输出之类的方法
  + 作为一个基准定义，以便在它之上构建更稳健的脚本语言
  + Web 服务器只是 `ECMAScript` 实现的一种宿主环境
  + 宿主环境提供 `ECMAScript`的基准实现和与环境自身交互必须的扩展（如： DOM）
  + 扩展使用`ECMAScript` 核心类型和语法，提供特定于环境的额外功能
  + 其他宿主环境还有：`Node.js`

  ##### ECMA-262 定义了什么 ？

  + 语法
  + 类型
  + 语句
  + 关键字
  + 保留字
  + 操作符
  + 全局对象

  ##### `ECMAScript` 只是对实现这个规范描述的所有方面的一门语言的称呼

  **`JavaScript` 实现了 `ECMAScript`**

+ ### `DOM`

  	+ 文档对象类型 （DOM,  Document Object Model）

  	+ `DOM` 将整个页面抽象为一组分层节点
  	+ `DOM` 通过创建表示文档的树，让开发者可以随心所欲地控制网页的内容和结构
  	+ 使用 **DOM API** 可以轻松地删除、添加、替换、修改节点
  	+ 对于浏览器来说，`DOM` 就是使用 `ECMAScript` 实现的，如今已经成为 `JavaScript` 语言的一大组成部分

+ ### `BOM`(浏览器对象模型) 

  + 用于支持访问和操作浏览器的窗口
  + 使用 `BOM` ，开发者可以操控浏览器显示页面之外的部分
  + 唯一一个没有相关标准的 `JavaScript` 实现
  + `HTML5` 以正式规范的形式涵盖了尽可能多的 **BOM 特性**
  + 总的来说，`BOM` 主要针对浏览器窗口和子窗口
  + 通常会把任何特定于浏览器的扩展都归在 `BOM`
    + 弹出新浏览器窗口的能力；
    + 移动 、缩放和关闭浏览器的能力；
    + `navigator` 对象，提供关于浏览器的详尽信息；
    + `location` 对象，提供浏览器加载页面的详尽信息；
    + `screen` 对象，提供关于用户屏幕分辨率的详尽信息；
    + `performance` 对象，提供浏览器内存占用、导航行为和时间统计的详尽信息；
    + 其他自定义对象，如 `XMLHttpRequest`；



### 总结

**JavaScript 是一门用来与网页交互的脚本语言**

+ `ECMAScript` : 由 **ECMA-262** 定义并提供核心功能
+ 文档对象模型 (DOM): 提供与网页内容交互的方法和接口
+ 浏览器对象模型 (BOM): 提供与浏览器交互的方法和接口





## HTML 中的 JavaScript

###  `<script>` 元素 (其有8个属性)

+ `async` ?:  表示立即下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载，**只对外部脚本文件有效**
+ `charset`?:  使用 `src` 属性指定的代码字符集，**大多数浏览器不在乎它的值**
+ `crossorigin`?： 配置相关请求的 `CORS` ( 跨域资源共享) 设置。默认不使用 `CORS`
  + `crossorigin = anonymous` 配置文件请求不必设置凭据标志
  + `crossorigin = use-credentials` 设置凭据标志，意味着出站请求会包含凭据
+ `defer`?：表示脚本可以延迟到文档完全被解析和显示之后再执行，**只对外部脚本文件有效**
+ `integrity`?：允许比对接收的资源和指定的加密签名以验证子资源的完整性；如果接收到的资源的签名与这个属性指定的签名不匹配，则页面会报错，脚本不会执行；这个属性可以用于确保内容分发网络（CDN, Content Delivery Network）不会提供恶意内容
+ `language` : 废弃
+ `src`?：表示包含要执行的代码的外部文件
+ `type`?：表示代码中脚本语言的内容类型
  + `type=module`, 代码会被当成 ES6 模块，而且只有这时候代码中才能出现 `import` 和 `export` 关键字

### 关于 `<script>` 

+ 在 `<script>` 元素中的代码被计算完成之前，页面的其余内容不会被加载，也不会被显示
+ 按照惯例，外部 JavaScript 文件的扩展名是.js。这不是必需的，因为浏览器不会检 查所包含 JavaScript 文件的扩展名。
+ 这就为使用服务器端脚本语言动态生成 JavaScript 代 码，或者在浏览器中将 JavaScript 扩展语言(如 TypeScript，或 React 的 JSX)转译为 JavaScript 提供了可能性。
+ 不管包含的是什么代码，浏览器都会按照`<script>`在页面中出现的顺序依次解释它们，前提是它们没有使用 `defer` 和 `async` 属性。第二个`<script>`元素的代码必须在第一个`<script>`元素的代码解 释完毕才能开始解释，第三个则必须等第二个解释完，以此类推。



### 标签位置

+ 如果把所有 JavaScript 文件都放在`<head>`里，也就意味着必须把所有 JavaScript 代码都下载、解析和解释完成后，才能开始渲 染页面(页面在浏览器解析到`<body>`的起始标签时开始渲染)。
+ 解决这个问题，现代 Web 应用程序通常 将所有 JavaScript 引用放在`<body>`元素中的页面内容后面



### 总结

**`JavaScript` 是通过 `<script>` 元素插入到 `HTML` 页面中的**

+ 如果包含外部文件，必须将`src` 属性设置为要包含文件的 `URL` , 文件可以和网页在同一台服务器上，也可以位于完全不同的域
+ 所有 `script` 元素会依照它们在网页中出现的次序被解释；在不使用 `defer` 和 `async` 属性的情况下，包含在 `script` 中的代码必须严格按照次序解释
+ 对于不推迟执行的脚本，浏览器必须解释完位于 `script` 中的代码，然后才能继续渲染页面的剩余部分；为此，通常应该把 `script` 元素放在页面末尾，介于主内容之后以及 `</body>` 标签之前
+ 可以使用 `defer` 属性把脚本推迟到文档渲染完毕之后再执行，推迟的脚本原则上按照它们被列出的次序执行
+ 可以使用 `async` 属性表示脚本不需要等待其他脚本，同时也不阻塞文档渲染，即异步加载；异步脚本不能保证按照它们在页面中的次序执行
+ 通过使用 `<noscript>` 元素，可以指定浏览器不支持脚本时显示的内容；如果浏览器支持并启用脚本，则 `noscript` 元素中的任何内容都不会被渲染





## 语言基础

> 任何语言的核心所描述的都是这门语言最基本的层面上是如何工作的；
>
> 涉及 语法、操作符、数据类型以及内置功能；
>
> 在此基础上才可以构建复杂的解决方案；
>
> `ECMA-262` 以一个名为 `ECMAScript` 的为语言的形式，定义了 `JavaScript` 的所有这些方面





### 语法

+ #### 区分大小写

+ #### 标识符

  + 所谓的标识符，就是变量、函数、属性或函数参数的名称。
  + 第一个字符必须是字母、下划线或 `$`
  + 剩下的其他字符可以是字母，下划线、`$` 或数字
  + 关键字、保留字、`true`、 `false` 和 `null` 不能作为标识符

+ #### 注释

  ```js
  // 单行注释
  
  /**
  * 多行注释 
  */
  ```

+ #### 严格模式

  + 严格模式是一种不同的 `JavaScript` 解析和执行模型
  + 所有现代浏览器都支持严格模式

  ```js
  "use strict"
  
  
  // 也可以单独指定一个函数在严格模式下执行
  
  function fn () {
  	"use strict"
  }
  ```

+ #### 语句

  + `ECMAScript ` 中的语句以分号结尾
  + 省略分号意味着由解析器确定语句在哪里结尾
  + 加分号便于开发者通过删除空行来压缩代码
  + 加分号有助于某些情况下提升性能，因为解析器会尝试在合适的位置补上分号以纠正语法错误

+ #### 关键字 和 保留字

  + 关键字和保留字不能用作标识符
  + 虽然现在还可以用作对象的属性名，但是为了确保兼容过去和未来的 **ECMAScript 版本** ，所以还是不要使用关键字和保留字来作为标识符和属性名

+ ### 变量

  + `ECMAScript` 变量是松散类型的，意思是变量可以用于保存任何类型的数据
  + 每个变量只不过是一个用于保存任意值的命名占位符

  #### var 关键字

  + ##### `var` 声明作用域

    ```js
    function test () {
    	var message = "hi"; // 局部变量
    }
    test()
    console.log(message) // 出错
    ```

    > `test()` 调用时会创建这个变量并给它赋值，  调用之后变量随即被销毁

    ```js
    function test () {
    	message = "hi" // 全局变量
    }
    test(); 
    console.log(message); // "hi"
    ```

    > 函数定义变量的时候省略 `var` 操作符，可以创建一个全局变量，函数调用后，并不会被销毁

    ```js
    var message = "hi", found = false, age = 27; // 可以同时声明多个变量并初始化
    ```

  + #####  `var` 声明提升

    ```js
    function foo () {
    	console.log(age);
      var age = 26;
    }
    foo(); // undefined
    ```

    > 函数内的所有变量声明都会被拉到函数作用域的顶部

  ####   `let` 声明

  + 不同于 `var`, `let` 声明的范围是块作用域，而`var` 声明的范围是函数作用域

    ```js
    if (true) {
    	var name = 'Kobe';
      console.log(name); // Kobe
    }
    console.log(name); // Kobe
    
    
    if (true) {
    	let age = 26;
      console.log(age); // 26
    }
    console.log(age); // ReferenceError: age 没有定义
    ```

  + `let` 也不允许同一个块作用域中出现冗余声明

    ```js
    var name;
    var name;
    
    let age;
    let age; // SyntaxError: 标识符 age 已经声明过了
    ```

  + `JavaScript` 引擎会记录用于变量声明的标识符以及其所在的块作用域，因此嵌套使用相同的标识符不会报错，因为同一个块中没有重复声明

    ```js
    var name = 'Nicholas';
    console.log(name) // 'Nicholas'
    if (true) {
    	var name = 'Matt';
      console.log(name); 'Matt'
    }
    
    let age = 30;
    console.log(age);  // 30
    if (true) {
    	let age = 26;
      console.log(age); // 26
    }
    ```

  + 暂时性死区

    + `let` 和`var` 的另一个重要的区别，就是 `let` 声明的变量不会在作用域中被提升

      ```js
      // name 会被提升
      console.log(name); // undefined
      var name = 'Kobe';
      
      
      // age 不会被提升
      console.log(age); // ReferenceError: age 没有定义
      let age = 26;
      ```

      > 在解析代码时，`JavaScript` 引擎也会注意出现在块后面的 `let` 声明，只不过在此之前不能以任何方式来引用未声明的变量。在 `let` 声明之前的执行瞬间被称为 "暂时性死区"，在此阶段引入任何后面才声明的变量都会抛出 `ReferenceError`

  + 全局声明

    + 与 `var` 关键字不同，使用 `let` 在全局作用域中声明的变量不会成为 `window` 对象的属性（`var` 声明的变量则会）

      ```js
      var name = 'Kobe';
      console.log(window.name); // 'Kobe'
      
      let age = 26;
      console.log(window.age); // undefined
      ```

      > `let` 声明仍然是在全局作用域中发生的，相应变量会在页面的生命周期内存续，因此，为了避免 `SyntaxError`, 必须确保页面不会重复声明同一个变量

  + 条件声明

    + 在使用 `var` 声明变量的时候，由于声明会被提升，`JavaScript` 引擎会自动将多余的声明在作用域顶部合并为一个声明 

    + 因为 `let` 的作用域是块，所以不可能检查前面是否已经使用`let` 声明过同名变量，同时也就不可能在没有声明的情况下声明它

      ```html
      <script>
        var name = 'Nicholas';
        let age = 26;
      </script>
      <script>
      // 假设脚本不确定页面中是否已经声明了同名变量
      var name = 'Matt';
      // 这里没问题，因为可以被作为一个提升声明来处理 // 不需要检查之前是否声明过同名变量
      let age = 36;
      // 如果 age 之前声明过，这里会报错 
      </script>
      ```

      > 使用 try/catch 语句或 typeof 操作符也不能解决，因为条件块中 let 声明的作用域仅限于该块。

      ```html
      <script>
        let name = 'Nicholas';
        let age = 36;
      </script>
      
      <script>
        // 那它可以假设还没有声明过
        if (typeof name === 'undefined') {
          let name;
        }
        // name 被限制在 if {} 块的作用域内 // 因此这个赋值形同全局赋值
        name = 'Matt';
        try {
       		console.log(age); // 如果 age 没有声明过，则会报错
        }
        catch(error) {
          12 13 14
          let age;
        }
        // age 被限制在 catch {}块的作用域内 // 因此这个赋值形同全局赋值
        age = 26;
      </script>
      ```

    + 为此，对于 `let` 这个新的 `ES6` 声明关键字，不能依赖条件声明模式

  + `for` 循环中的 `let` 声明

    + 在`let` 出现之前，`for` 循环定义的迭代变量会渗透到循环体外部

      ```js
      for (var i = 0; i < 5; ++i) {
      	// 循环逻辑
      }
      console.log(i) // 5
      
      
      
      for (let j = 0; j < 5; ++j) {
      	// 循环逻辑
      }
      console.log(j) // ReferenceError: j 没有定义
      ```

    + 改成 `let` 之后，这个问题就消失了，因为迭代变量的作用域仅限于 `for` 循环块内部

    + 在使用 `let` 声明迭代变量时，`JavaScript` 引擎在后台会为每个迭代循环声明一个新的迭代变量

    + 每个 `setTimeout` 引用的都是不同的实例

      ```js
      for (var i = 0; i < 5; ++i) {
              setTimeout(() => console.log(i), 0)
      }
      // 你可能以为会输出0、1、2、3、4 // 实际上会输出5、5、5、5、5
      
      for (let i = 0; i < 5; ++i) {
              setTimeout(() => console.log(i), 0)
      }
      // 会输出0、1、2、3、4
      ```

      > 我曾经想过，`let` 是可以在不同的块级作用域中重复声明变量的，所以在`for` 循环中，是不是每次循环的时候就会重新声明一个变量 `i`, 从而达到`JavaScript` 引擎在后台会为每个迭代循环声明一个新的迭代变量这个效果；
      >
      > 然而，查阅了很多资料，均表示:
      >
      > 在 JavaScript 的 `for` 循环中，当第二次回到条件表达式之后，**不会**重新声明变量。初始化表达式（例如 `let i = 0`）只在循环开始时执行一次。这意味着循环中定义的变量只被声明和初始化一次，然后在每次循环迭代中被更新

      然后我尝试用`js` 代码去模拟 `for` 循环的过程：

      ```js
      let i = 0;
      
      if (i < 5) {
        setTimeout(() => console.log(i), 0);
      }
      i++;
      {
        i; // 块级作用域的i
        if (i < 5) {
          setTimeout(() => console.log(i), 0);
        }
      }
      i++;
      {
        i; // 块级作用域的i
        if (i < 5) {
          setTimeout(() => console.log(i), 0);
        }
      }
      
      变量声明和初始化:
      ```

      在上面的模拟中：

      + `let i = 0`; 声明并初始化变量 i。
        块级作用域:

      + 每个 {...} 块创建了一个新的作用域。在 `for `循环中，`let `也会为每次迭代创建一个新的作用域。
        条件检查:

      + `if (i < 5)` 检查条件是否满足，类似于` for `循环中的条件表达式。
        执行动作:

      + `setTimeout(() => console.log(i), 0)` 类似于 `for` 循环体内的操作。
        变量更新:

      + `i++  `更新变量，与 `for` 循环中的更新表达式类似。
        作用域内变量引用:

      + 在每个 {...} 块中，`i` 被 **重新引用**。这与` for`循环中的每次迭代独立的 `i `类似。

      但是很显然，执行结果并不是我们预期的那样

      后面我突然间想到思路出现的问题在于，块级作用域并非只有 {...}, 我忽视了另一个重要的块级作用域： 函数作用域

      或许将模拟的代码改成以下代码，会更加接近 `JavaScript` 引擎对`for` 循环的处理过程 :

      ```js
      {
        let i = 0;
      
        if (i < 5) {
          // 每次迭代都会调用一个新的 IIFE
          // 为每个 setTimeout 回调创建一个独立的作用域
          (function (i) {
            setTimeout(() => console.log(i), 0);
          }(i))
        }
        i++;
         if (i < 5) {
          // 每次迭代都会调用一个新的 IIFE
          // 为每个 setTimeout 回调创建一个独立的作用域
          (function (i) {
            setTimeout(() => console.log(i), 0);
          }(i))
        }
        i++;
        if (i < 5) {
          // 每次迭代都会调用一个新的 IIFE
          // 为每个 setTimeout 回调创建一个独立的作用域
          (function (i) {
            setTimeout(() => console.log(i), 0);
          }(i))
        }
      }
      ```

      > 所以，这样看来，`let` 声明在 `for` 循环中确实只执行一次；
      >
      > 我们不难看出，这个问题其实就是考验我们对作用域的理解；
      >
      > 在每次函数的调用过程中，都会创建一个函数块级执行上下文，在这个上下文中，会声明一些变量(函数体内代码声明的变量以及形参变量)，这些变量仅能在这个上下文中被访问，或者通过**闭包**供外部变量访问。
      >
      > 所以上面的 `setTimeout`执行时 访问到的是`IIFE` 执行时创建的变量实例 `i`；
      >
      > 回到最初的问题，我们已经找到了答案，那就是在 `forr` 循环中，`let` 变量声明和初始化只执行一次。 

      或许看到这里，还有一个疑问，那就是`IIFE` 执行时创建的变量实例 `i`难道不是通过`var`、`let`、`const` 声明的吗？

      其实这就涉及到函数调用时，`JS` 引擎做了哪些关键步骤：

      + **创建执行上下文**
        + 当函数被调用时，JavaScript引擎会为该函数创建一个新的执行上下文。执行上下文是存储函数运行时所有信息的内部数据结构。
      + **变量环境的创建**
        + 在这个执行上下文中，创建一个称为“变量环境”的内部对象，用于存储函数中定义的所有局部变量（使用 `var`、`let` 或 `const` 声明的）。
      + **参数的赋值**:
        + 函数的参数会被赋值到新创建的执行上下文中。这些参数在内部表现为局部变量。
      + **函数体的执行**:
        + 接下来，`JavaScript`引擎执行函数体。在这个过程中，任何新声明的局部变量都会被添加到当前执行上下文的变量环境中。
      + **作用域链**:
        + 每个执行上下文都有一个所谓的作用域链，它包含当前函数作用域以及所有外部作用域的引用。这使得函数能够访问在其外部作用域中定义的变量。
      + **函数执行完毕**:
        + 当函数执行完毕，其执行上下文被从调用栈中弹出。如果没有其他引用指向这个执行上下文，它会被垃圾回收器回收

      > 所以，当一个函数被调用时，其内部的变量声明是通过创建一个新的执行上下文和相应的变量环境来实现的，而不是通过在每次函数调用时重新执行 `let`、`var` 或 `const` 声明。这是JavaScript引擎的内部机制，确保每次函数调用都有其独立的作用域和变量。

      

+ 

+ 

+ 

+ 

  

  

  

  

  

  

  

  